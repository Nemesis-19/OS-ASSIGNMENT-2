main.c : The first few lines of the code are the appropriate header files used for the smooth propagation of the driver code written below. Firt part of the driver code is the "handler" function, which takes 3 parameters, an integer, an a pointer to siginfo_t (which is a structure that is passed as the second parameter to a user signal handler function, if the SA_SIGINFO flag was specified when the handler was installed with sigaction()), and a void pointer. Under this function, we make a pointer to a 64 bit unsigned integer, and point this to value pointer coming under values assigned to the signal invoking this handler, and finally we print (using %llu) the unisgned 64 bit integer to which ptr points to using the printf function (using %llu). Under the main function, the very first command is the fork() command which creates the parent and child processes, as per asked in the question. Under the child process (S1 process, interms of question nomenclature), we create a sigaction structure, which will invoke the the sigterm handler when the targeted signal is recieved and we have flaged the SA_SIGINFO so that we can use all the information which the signal carries. Then there is the infinite while loop which ensures that the sigaction can invoke the handler till infinity using the sigaction(SIGTERM, &action, 0) command. And we even check if the invoking command is working or not, then there is the sleep(1) command. Then under the parent code, we initiate a character array, which stores the pid of the parent process. Then there is the code block to create 2 child processes, first is the SR process, under which we use the execlp command (it is the member of the exec family, p here stande for path), which takes the file name, and a string as arguments (we pass the typecasted pid here), next is the ST process which similarly uses execlp with the different filename but same character array.

SR.c : The first few lines of the code are the appropriate header files used for the smooth propagation of the driver code written below. Firt part of the driver code is the "alrm_handler" function, which takes 3 parameters, an integer, an a pointer to siginfo_t (which is a structure that is passed as the second parameter to a user signal handler function, if the SA_SIGINFO flag was specified when the handler was installed with sigaction()), and a void pointer. Under this, sleep() is used as the first command, to ensure appropriate gap and visibilty of the output, then there is the code block, which uses rdrand function to generate an unsigned 64 bit integer. There is error handling done to ensure that the integer is successfully generated. Then we print (using %llu) the random integer. Then there is union command which uses its functionality to point this 64 bit integer under its sival pointer available. This union will be sent when the signal is sent to the main function sigterm_handler. Then we use the sigqueue command to finally send the signal to the sigterm handler of the main function. Error handling has been done to ensure that signal is generated to the main function. Under the main function, we first intiate the sr_pid, using the array argument passed from the main function. Next in the program (SR program, interms of question nomenclature), we create a sigaction structure, which will invoke the the sigterm handler when the targeted signal is recieved and we have flaged the SA_SIGINFO so that we can use all the information which the signal carries. Then there is the union command which intiates its sival integer as the sr_pid, which is to be sent with the signal for sigalrm. Then there is the infinite while loop which ensures that the sigaction can invoke the handler till infinity using the sigaction(SIGTERM, &action, 0) command. And we even check if the invoking command is working or not. The we finally send the signal using the sigqueue command, passing all valuable information to the sigalrm handler.

ST.c : The first few lines of the code are the appropriate header files used for the smooth propagation of the driver code written below. Firt part of the driver code is the "alrm_handler" function, which takes 3 parameters, an integer, an a pointer to siginfo_t (which is a structure that is passed as the second parameter to a user signal handler function, if the SA_SIGINFO flag was specified when the handler was installed with sigaction()), and a void pointer. Under this, sleep() is used as the first command, to ensure appropriate gap and visibilty of the output. First under this function we are counting CPU time stamp counter using inline RDTSC instruction then we are converting the secs generated using rdtsc to  readable time. Then there is the code block, which uses inline rdtsc to generate an unsigned 64 bit integer. Then we print (using %llu) the random integer. Then there is union command which uses its functionality to point this 64 bit integer under its sival pointer available. This union will be sent when the signal is sent to the main function sigterm_handler. Then we use the sigqueue command to finally send the signal to the sigterm handler of the main function. Error handling has been done to ensure that signal is generated to the main function. Finally is the kill command. Under the main function, we first intiate the st_pid, using the array argument passed from the main function. Next in the program (SR program, interms of question nomenclature), we create a sigaction structure, which will invoke the the sigterm handler when the targeted signal is recieved and we have flaged the SA_SIGINFO so that we can use all the information which the signal carries. Then there is the union command which intiates its sival integer as the sr_pid, which is to be sent with the signal for sigalrm. Then there is the setitimer command to set the timer fro calling sigalrm, and is intervaled for 0 to 1000000, using the sittimer struct and the condtioning commands. Then there is the infinite while loop which ensures that the sigaction can invoke the handler till infinity using the sigaction(SIGTERM, &action, 0) command. And we even check if the invoking command is working or not. The we finally send the signal using the sigqueue command, passing all valuable information to the sigalrm handler.